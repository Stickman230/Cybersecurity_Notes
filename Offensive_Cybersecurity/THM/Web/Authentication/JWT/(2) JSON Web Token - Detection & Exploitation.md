#JWT #WEB #WebAuthentication

# Sensitive Information Disclosure

- *Cookie-based* session management approach is using the server-side session to store several parameters.
	- In PHP, you can use $SESSION['var']=data to store a value associated with the user's session. 

- *Tokens*, the claims are exposed as the entire JWT is sent client-side.

It can lead to **sensitive information disclosure** :

- *Credential disclosure* with the password hash, or even worse, the clear-text password being sent as a claim.
- *Exposure of internal network information* such as the private IP or hostname of the authentication server.

---
# Signature validation mistakes

### Not Verifying the Signature

- The first issue with signature validation is when there is *no signature validation*. 
	- If the server does not verify the signature of the JWT, then it is possible to modify the claims in the JWT to whatever you prefer them to be.
==EX:== 

With signature : `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30`

Without signature : `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.`

***Leave only the dot for bypass***

### Downgrading to None

-  JWTs support the `none` signing algorithm, which effectively means that no signature is used with the JWT. 
	- In that case, you can simply change the algorithm specified in your JWT as `none`, which would then cause the library used for signature verification to always return true, thus allowing you again to forge any claims within your token.
==EX:==

With signature algorithm set to **none**:`eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.`

### Weak Symmetric Secrets

- If a symmetric signing algorithm is used, the security of the JWT relies on the strength and entropy of the secret used. I
	- f a weak secret is used, it may be possible to perform offline cracking to recover the secret. 
==EX:==

1. Save the JWT to a text file called jwt.txt.
2. Download a common JWT secret list.  You can use [JWT secret cracking lists](https://raw.githubusercontent.com/wallarm/jwt-secrets/master/jwt.secrets.list)Â 
3. Use Hashcat to crack the secret using `hashcat -m 16500 -a 0 jwt.txt jwt.secrets.list`

### Signature Algorithm Confusion

- A common issue with signature validation is when an algorithm confusion attack can be performed. 
	- This is similar to the `None` downgrade attack, however, *it specifically happens with confusion between symmetric and asymmetric signing algorithms*. 
	- If an asymmetric signing algorithm, for example, RS256 is used, it may be possible to downgrade the algorithm to HS256. In these cases, some libraries would default back to using the public key as the secret for the symmetric signing algorithm. 
	- **Since the public key can be known**, you can forge a valid signature by using the HS256 algorithm in combination with the public key.

==Development Mistake : ==
```python
payload = jwt.decode(token, self.secret, algorithms=["HS256", "HS384", "HS512", "RS256", "RS384", "RS512"])
```

---
# JWT Token lifetime

if the `exp` value is set too large (or not set at all), the token would be valid for too long or might even never expire. With cookies, the cookie can be expired server-side. However, JWTs do not have this same feature built-in.